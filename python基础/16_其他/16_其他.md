



## 线程池

Python的线程虽然是真正的线程，但解释器执行代码时，有一个**GIL**锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。

但是对于IO密集型的任务，多线程还是起到很大效率提升，这是协同式多任务
当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。

一个线程的运行时间可以分为3部分：线程的启动时间、线程体的运行时间和线程的销毁时间。在多线程处理的情景中，如果线程不能被重用，就意味着每次创建都需要经过启动、销毁和运行3个过程。这必然会增加系统相应的时间，降低了效率。

对于任务数量不断增加的程序，每有一个任务就生成一个线程，最终会导致线程数量的失控，例如，整站爬虫，假设初始只有一个链接a，那么，这个时候只启动一个线程，运行之后，得到这个链接对应页面上的b，c，d，，，等等新的链接，作为新任务，这个时候，就要为这些新的链接生成新的线程，线程数量暴涨。在之后的运行中，线程数量还会不停的增加，完全无法控制。所以，对于任务数量不端增加的程序，固定线程数量的线程池是必要的。

python3中自带了concurrent.futures模块，可以实现线程池

~~~
from concurrent.futures import ThreadPoolExecutor
import time
import random
from concurrent.futures import ThreadPoolExecutor
import time

def hello(num):
    time.sleep(random.randint(1, 3))
    print("{}只小鸭子，咿呀咿呀呦".format(num))

if __name__ == "__main__":
    excutor1 = ThreadPoolExecutor(max_workers=3)
    for i in range(1,8):
        future = excutor1.submit(hello,i)
        future.done()
    with ThreadPoolExecutor(3) as executor1:
    executor1.map(hello, [1,2,3])
~~~

在提交任务的时候，有两种方式，一种是submit（）函数，另一种是map（）函数，两者的主要区别在于：

- map可以保证输出的顺序, submit输出的顺序是乱的
- 如果你要提交的任务的函数是一样的，就可以简化成map。但是假如提交的任务函数是不一样的，或者执行的过程之可能出现异常（使用map执行过程中发现问题会直接抛出错误）就要用到submit（）
- submit和map的参数是不同的，submit每次都需要提交一个目标函数和对应的参数，map只需要提交一次目标函数，目标函数的参数放在一个迭代器（列表，字典）里就可以。

## 一、协程

协程：又称微线程，纤程，是一种用户态的轻量级线程
线程是系统级别的，他们是由操作系统调度。协程是程序级别的，由程序员根据需求自己调度。我们把一个线程中的一个个函数称为子程序，那么子程序在执行的过程中可以中断去执行别的子程序。别的子程序也可以中断回来继续执行之前的子程序，这就是协程。也就是说同一线程下的一段代码1执行执行着就可以中断，然后去执行另一段代码2，当再次回来执行代码块1的时候，接着从之前中断的地方开始执行


子程序：在所有的语言中都是层级调用，比如A中调用B，B在执行过程中调用C，C执行完返回，B执行完返回，最后是A执行完毕。是通过栈实现的，一个线程就是执行一个子程序，子程序的调用总是有一个入口，一次返回，调用的顺序是明确的

- 优点：
  - 1、无需线程上下文切换的开销，协程避免了无意义的调度，由此提高了性能，但是，程序员必须自己承担调度的责任，同时协程也失去了标准线程使用多CPU的能力
  - 2、无需原子操作锁定及同步的开销
  -  3、方便切换控制流，简化编程模型
  -  4、高并发+高扩展性+低成本，一个CPU支持上万个协程不是问题

- 缺点：
  - 1、无法利用多核资源，协程的本质是单个线程，它不能同时将单个CPU的多个核使用上，协程需要和进程配合使用才能运行在多CPU上。但是一般不需要，除非是CPU密集型的应用
  - 2、进行阻塞操作(耗时IO)会阻塞整个程序

### 1.创建协程

python对协程的支持是通过generator实现的

~~~
def demo():
    print('-> 开始')
    x = yield     #yield将接收send过来的值2赋值给x；并返回None
    print('-> 接收', x)  #打印 -> 接收 2
    c = yield (1 + x)  #接收send过来的3，并把3返回
    print("x,c:",x,c)  #打印 x,c: 2 3

sc = demo(1)  #生成协程对象
#next将激活协程执行到第一个yield
print(next(sc))  #获取到的返回值None,打印None
print(sc.send(2)) #打印3
sc.send(3)  #下面没有yield,抛出异常StopIteration
~~~

- yield的作用
  - 如果yield出现在赋值运算符右边，表示yield将接收协程对象发送（sc.send(2)）过来的数据赋值给赋值运算符的左边的变量。
  - 如果yield右边有表达式，表示yield将把表达式的返回给调用者

- next作用激活协程执行到下一个yield，等价于sc.send(None)

- 协程在运行过程中有四个状态：
  - GEN_CREATE:等待开始执行
  - GEN_RUNNING:解释器正在执行，这个状态一般看不到
  - GEN_SUSPENDED:在yield表达式处暂停
  - GEN_CLOSED:执行结束

~~~
from inspect import  getgeneratorstate
print(getgeneratorstate(sc))
sc.send(None)
print(getgeneratorstate(sc))
sc.send(2)
print(getgeneratorstate(sc))
sc.send(3)
print(getgeneratorstate(sc))
~~~

### 2.生产者和消费者

传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。

如果改用协程，生产者生产消息后，直接通过`yield`跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高

~~~
import threading
import time


def product(c):
    print(threading.currentThread().name)
    c.send(None)
    for i in range(1,4):
        print("蒸包子：{}".format(i))
        res = c.send(i)
        print("客户反馈：{}".format(res))
        time.sleep(1)
    c.close()
def eat():
    print(threading.currentThread().name)
    res = ''
    while True:
        bz = yield res
        if not bz:
            return
        print("吃包子：{}".format(bz))
        res = "真好吃"

cs = eat()
product(cs)
~~~

## 二、单元测试和文档测试

### 2.1 单元测试

> 作用：对一个函数，模块或者一个类进行正确性的校验工作

### 2.2 文档测试

> 作用：可以提取注释中的代码执行
>
> doctest严格Python交互模式下的写法

## 三、json模块

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。

json的组成：

- 数据保存在键值对中：‘name':'tom
- 数据项由逗号分隔
- {}表示对象（字典）
- []表示列表

实例：{
​                "省": "北京",
​               "市": [{"市名": "北京","编码": "101010100"}, { "市名": "朝阳", "编码": "101010300"} <br>           }

在python解析json，可以引入内置json模块

- json字符串转python对象

~~~
import json

s1 = """
{"省": "北京","市": [{"市名": "北京","编码": "101010100"}, { "市名": "朝阳", "编码": "101010300"}]}
"""
obj1 = json.loads(s1)
print(obj2,type(obj2))
~~~

- python对象转json字符串

~~~
person = {"name":"tom", "age":18, "sex":True}
s1 = json.dumps(person)
print(s1,type(s1))
~~~

- 加载json文件

~~~
with open('json/car.json',encoding='utf-8') as fp:
    cars = json.load(fp)
    print(cars)
~~~

- 写json文件

~~~
d1 = {'name':'jerry','age':18}
with open('person.json','w') as fp:
    json.dump(d1,fp)
~~~

## 四、发邮件和发短信

- 发短信

  阿里云

  - 下载官方的demohttps://help.aliyun.com/document_detail/55359.html?spm=a2c4g.11186623.4.3.SK7RET

  - 到demo目录中做安装

    ```
    打开cmd
    python setup.py install  #需要选择python的版本
    ```

  - 配置发送的const.py

    ```
    ACCESS_KEY_ID = "LTAIDHOYSjYcvyVt"   #
    ACCESS_KEY_SECRET = "qrEgykmXX4e6GUMFOqzuiLZ5gsUxSC" 
    ```


  ```
  # -*- coding: utf-8 -*-
  import sys
  import json
  
  from aliyunsdkdysmsapi.request.v20170525 import SendSmsRequest
  from aliyunsdkdysmsapi.request.v20170525 import QuerySendDetailsRequest
  from aliyunsdkcore.client import AcsClient
  import uuid
  from aliyunsdkcore.profile import region_provider
  from aliyunsdkcore.http import method_type as MT
  from aliyunsdkcore.http import format_type as FT
  import const
  
  
  """
  短信业务调用接口示例，版本号：v20170525
  
  Created on 2017-06-12
  
  """
  try:
      reload(sys)
      sys.setdefaultencoding('utf8')
  except NameError:
      pass
  except Exception as err:
      raise err
  
  # 注意：不要更改
  REGION = "cn-hangzhou"
  PRODUCT_NAME = "Dysmsapi"
  DOMAIN = "dysmsapi.aliyuncs.com"
  
  acs_client = AcsClient(const.ACCESS_KEY_ID, const.ACCESS_KEY_SECRET, REGION)
  region_provider.add_endpoint(PRODUCT_NAME, REGION, DOMAIN)
  
  def send_sms(business_id, phone_numbers, sign_name, template_code, template_param=None):
      smsRequest = SendSmsRequest.SendSmsRequest()
      # 申请的短信模板编码,必填
      smsRequest.set_TemplateCode(template_code)
  
      # 短信模板变量参数
      if template_param is not None:
          smsRequest.set_TemplateParam(template_param)
  
      # 设置业务请求流水号，必填。
      smsRequest.set_OutId(business_id)
  
      # 短信签名
      smsRequest.set_SignName(sign_name)
  	
      # 数据提交方式
  	# smsRequest.set_method(MT.POST)
  	
  	# 数据提交格式
      # smsRequest.set_accept_format(FT.JSON)
  	
      # 短信发送的号码列表，必填。
      smsRequest.set_PhoneNumbers(phone_numbers)
  
      # 调用短信发送接口，返回json
      smsResponse = acs_client.do_action_with_exception(smsRequest)
  
      # TODO 业务处理
  
      return smsResponse
  
  
  
  if __name__ == '__main__':
      __business_id = uuid.uuid1()
      params = "{\"number\":\"12345\"}"
      res = send_sms(__business_id, "15116905290", "成少雷", "SMS_102315005", params)
      print(json.loads(res))
     
  ```

- 发送邮件

  163邮箱

## 五. 枚举类【扩展】

> 枚举类型看做一种标签或者一系列常量的集合，常用来表示某些特定的有限的集合
>
> 举例：星期，月份、性别
>
> 可以使用字典，类的形式实现
>
> ```python
> #1.字典
> weekday = {
>     "MON":1,
>     "TUS":2,
>     "WED":3,
>     "THUR":4,
>     "FRI":5
> }
> 
> print(weekday)
> weekday["MON"] = weekday["FRI"]
> print(weekday)
> 
> 
> #2.类
> class Color(object):
>     #类属性
>     RED = 0
>     GREEN = 1
>     BLUE = 2
> 
> c = Color()
> Color.RED = 10
> 
> #说明：枚举：不能实例化，其中的枚举成员不能随意更改
> ```
>
> 上面两种定义方式缺点是很明显的，就是枚举的值是可修改的
>
> Python3.4之后提供了enum
>
> ```python
> from enum import  Enum,IntEnum,unique
> 
> #1
> #在Python3.4之后新增的特性。enum标准库
> #enum提供了Enum【类】、IntEnum【类】、unique【@unique，装饰器】三个工具
> #Enum:继承自Enum，普通的枚举类
> #IntEnum:继承自IntEnum，限定枚举成员必须为整数类型
> #unique：@unique，作为一个装饰器，限定枚举成员的值不可重复
> 
> #2
> #WEEKDAY被称为枚举类
> try:
>     @unique
>     class WEEKDAY(Enum):
>         # 类属性/枚举成员/枚举常量：命名最好遵循常量命名法
>         MON = 5
>         TUES = 2
>         WED = 3
>         THUR = 4
>         FRI = 5
> except ValueError as e:
>     print(e)
> 
> #duplicate【重复】 values found in <enum 'WEEKDAY'>: FRI -> MON
> 
> 
> #3.ENUM的成员均为单例，并且不可更改，不能进行实例化
> #COLOR.RED = 10   #AttributeError: Cannot reassign members.
> print(COLOR.RED)   #COLOR.RED
> 
> #4获取枚举的名称和值
> print(WEEKDAY.MON,WEKKDAY['MON'],WEEKDAY.MON.name)  #名称
> print(WEEKDAY.MON.VALUE)  #值
> 
> #5枚举常见操作
> for mem in WEEKDAY:
>      print(mem.name,mem.value)
> #可进行判等比较
> print(WEEKDAY.MON != WEEKDAY.FRI)  #TRUE
> #身份比较
> print(WEEKDAY.MON is not WEEKDAY.FRI)
> ```

## 六.python2和python3的区别



